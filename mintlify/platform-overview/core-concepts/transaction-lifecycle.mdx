---
title: "Transaction Lifecycle"
description: "Follow a payment from creation to settlement"
---

Understanding the transaction lifecycle helps you build robust payment flows, handle edge cases, and provide accurate status updates to your customers.

## Transaction States

Transactions progress through several states from creation to completion:

```
PENDING → PROCESSING → COMPLETED
                    ↓
                  FAILED
```

### Status Descriptions

| Status | Description | Next State | Actions Available |
|--------|-------------|------------|-------------------|
| **PENDING** | Transaction created, awaiting processing | PROCESSING, FAILED | Monitor status |
| **PROCESSING** | Payment being routed and settled | COMPLETED, FAILED | Monitor status |
| **COMPLETED** | Successfully delivered to recipient | Terminal | None (final state) |
| **FAILED** | Transaction failed, funds refunded if applicable | Terminal | Create new transaction |
| **REJECTED** | Rejected by recipient or compliance | Terminal | None (final state) |
| **REFUNDED** | Completed transaction later refunded | Terminal | None (final state) |
| **EXPIRED** | Quote or payment expired before execution | Terminal | Create new quote |

<Tip>
**Terminal statuses**: `COMPLETED`, `REJECTED`, `FAILED`, `REFUNDED`, `EXPIRED`

Once a transaction reaches a terminal status, it will not change further.
</Tip>

## Outgoing Transaction Flow

**Your customer/platform sends funds to an external recipient.**

### Step-by-Step

<Steps>
  <Step title="Create Quote">
    Lock in exchange rate and fees:

    ```bash
    POST /quotes

    {
      "source": {"accountId": "InternalAccount:abc123"},
      "destination": {"accountId": "ExternalAccount:xyz789"},
      "lockedCurrencySide": "SENDING",
      "lockedCurrencyAmount": 100000
    }
    ```

    **Response:**
    - Quote ID
    - Locked exchange rate
    - Expiration time (1-5 minutes)
  </Step>

  <Step title="Execute Quote">
    Initiate the payment:

    ```bash
    POST /quotes/{quoteId}/execute
    ```

    **Result:**
    - Transaction created with status `PENDING`
    - Source account debited immediately
    - `OUTGOING_PAYMENT` webhook sent
  </Step>

  <Step title="Processing">
    Grid handles:
    - Currency conversion (if applicable)
    - Routing to appropriate payment rail
    - Settlement with destination bank/wallet

    **Status**: `PROCESSING`

    **Webhook**: `OUTGOING_PAYMENT` with updated status
  </Step>

  <Step title="Completion or Failure">
    **Success Path:**
    - Funds delivered to recipient
    - Status: `COMPLETED`
    - `settledAt` timestamp populated
    - Final `OUTGOING_PAYMENT` webhook sent

    **Failure Path:**
    - Delivery failed (invalid account, etc.)
    - Status: `FAILED`
    - `failureReason` populated
    - Funds automatically refunded to source account
    - Final `OUTGOING_PAYMENT` webhook sent
  </Step>
</Steps>

### Timeline Example

```
T+0s:    Create quote
T+30s:   Execute quote → PENDING
T+2min:  Processing → PROCESSING
T+5min:  Delivered → COMPLETED
```

Timing varies by payment rail:
- **Lightning**: Seconds
- **RTP/PIX/UPI**: Seconds to minutes
- **SEPA Instant**: Minutes
- **ACH**: 1-2 business days
- **Wire**: Same day

### Webhook Payloads

**On Creation (PENDING):**

```json
{
  "type": "OUTGOING_PAYMENT",
  "transaction": {
    "id": "Transaction:...",
    "status": "PENDING",
    "type": "OUTGOING",
    "sentAmount": {"amount": 100000, "currency": {"code": "USD"}},
    "receivedAmount": {"amount": 92000, "currency": {"code": "EUR"}},
    "createdAt": "2025-10-03T15:00:00Z"
  }
}
```

**On Completion:**

```json
{
  "type": "OUTGOING_PAYMENT",
  "transaction": {
    "id": "Transaction:...",
    "status": "COMPLETED",
    "settledAt": "2025-10-03T15:05:00Z"
  }
}
```

**On Failure:**

```json
{
  "type": "OUTGOING_PAYMENT",
  "transaction": {
    "id": "Transaction:...",
    "status": "FAILED",
    "failureReason": "INVALID_BANK_ACCOUNT"
  }
}
```

## Incoming Transaction Flow

**Your customer/platform receives funds from an external sender (UMA-based).**

<Note>
Incoming transactions are primarily used in Global P2P (UMA) flows. They represent payments sent TO your customers from external platforms.
</Note>

### Step-by-Step

<Steps>
  <Step title="Receive Webhook Notification">
    Grid sends `INCOMING_PAYMENT` webhook with status `PENDING`:

    ```json
    {
      "type": "INCOMING_PAYMENT",
      "transaction": {
        "id": "Transaction:...",
        "status": "PENDING",
        "type": "INCOMING",
        "sentAmount": {"amount": 100000, "currency": {"code": "USD"}},
        "receivedAmount": {"amount": 100000, "currency": {"code": "USD"}},
        "senderInfo": {
          "fullName": "Bob Smith",
          "email": "bob@example.com"
        },
        "customerId": "Customer:...",
        "destinationUmaAddress": "$alice@yourplatform.com"
      }
    }
    ```
  </Step>

  <Step title="Review and Approve/Reject">
    You have **5 seconds** to respond synchronously:

    **Approve:**
    ```http
    HTTP/1.1 200 OK
    ```

    **Reject:**
    ```http
    HTTP/1.1 403 Forbidden
    Content-Type: application/json

    {
      "reason": "COMPLIANCE_REJECTION",
      "message": "Customer not eligible for this transaction"
    }
    ```

    If you need more time, return 200 OK and use async endpoints:
    ```bash
    POST /transactions/{transactionId}/approve
    # or
    POST /transactions/{transactionId}/reject
    ```
  </Step>

  <Step title="Processing">
    If approved:
    - Grid converts currency (if needed)
    - Delivers to customer's internal account
    - Status: `PROCESSING`

    If rejected:
    - Funds returned to sender
    - Status: `REJECTED`
  </Step>

  <Step title="Completion">
    **On Success:**
    - Customer account credited
    - Status: `COMPLETED`
    - Final `INCOMING_PAYMENT` webhook sent

    **On Failure:**
    - Delivery failed
    - Status: `FAILED`
    - Funds returned to sender
  </Step>
</Steps>

### Timeline Example

```
T+0s:    INCOMING_PAYMENT webhook (PENDING)
T+1s:    Your app approves (200 OK)
T+5s:    Processing → PROCESSING
T+10s:   Delivered → COMPLETED
```

### Approval Patterns

<Tabs>
  <Tab title="Auto-Approve">
    Automatically approve all payments:

    ```javascript
    app.post('/webhooks/grid', async (req, res) => {
      const {transaction, type} = req.body;

      if (type === 'INCOMING_PAYMENT' && transaction.status === 'PENDING') {
        // Auto-approve
        return res.status(200).json({received: true});
      }

      // Handle other webhooks
      res.status(200).json({received: true});
    });
    ```
  </Tab>

  <Tab title="Compliance Check">
    Check sender against watchlists before approving:

    ```javascript
    app.post('/webhooks/grid', async (req, res) => {
      const {transaction, type} = req.body;

      if (type === 'INCOMING_PAYMENT' && transaction.status === 'PENDING') {
        const {senderInfo} = transaction;

        // Quick compliance check (must complete in <5s)
        const isAllowed = await quickComplianceCheck(senderInfo);

        if (!isAllowed) {
          return res.status(403).json({
            reason: 'COMPLIANCE_REJECTION',
            message: 'Sender failed compliance screening'
          });
        }

        return res.status(200).json({received: true});
      }

      res.status(200).json({received: true});
    });
    ```
  </Tab>

  <Tab title="Async Approval">
    Queue for manual review:

    ```javascript
    app.post('/webhooks/grid', async (req, res) => {
      const {transaction, type} = req.body;

      if (type === 'INCOMING_PAYMENT' && transaction.status === 'PENDING') {
        // Queue for async review
        await queueForReview(transaction);

        // Acknowledge receipt (payment still pending)
        return res.status(200).json({received: true});
      }

      res.status(200).json({received: true});
    });

    // Later, after review...
    async function processReview(transactionId, approved) {
      if (approved) {
        await fetch(`${API_BASE}/transactions/${transactionId}/approve`, {
          method: 'POST',
          headers: {Authorization: `Basic ${credentials}`}
        });
      } else {
        await fetch(`${API_BASE}/transactions/${transactionId}/reject`, {
          method: 'POST',
          headers: {Authorization: `Basic ${credentials}`},
          body: JSON.stringify({
            reason: 'MANUAL_REJECTION',
            message: 'Failed manual review'
          })
        });
      }
    }
    ```
  </Tab>
</Tabs>

## Same-Currency Transfers

For same-currency transfers without quotes:

### Transfer-Out (Internal → External)

```bash
POST /transfer-out

{
  "source": {"accountId": "InternalAccount:abc123"},
  "destination": {"accountId": "ExternalAccount:xyz789"},
  "amount": 100000
}
```

**Response:**

```json
{
  "id": "Transaction:...",
  "status": "PENDING",
  "type": "OUTGOING"
}
```

Follows same lifecycle as quote-based outgoing transactions.

### Transfer-In (External → Internal)

```bash
POST /transfer-in

{
  "source": {"accountId": "ExternalAccount:xyz789"},
  "destination": {"accountId": "InternalAccount:abc123"},
  "amount": 100000
}
```

Only works for "pullable" external accounts (Plaid-linked, debit cards).

## Monitoring Transactions

### Via Webhooks (Recommended)

Subscribe to transaction webhooks for real-time updates:

```javascript
app.post('/webhooks/grid', async (req, res) => {
  const {transaction, type} = req.body;

  if (type === 'OUTGOING_PAYMENT') {
    await updateTransactionStatus(transaction.id, transaction.status);

    if (transaction.status === 'COMPLETED') {
      await notifyCustomer(transaction.customerId, 'Payment delivered!');
    } else if (transaction.status === 'FAILED') {
      await notifyCustomer(transaction.customerId, `Payment failed: ${transaction.failureReason}`);
    }
  }

  res.status(200).json({received: true});
});
```

### Via Polling (Backup)

Query transaction status periodically:

```bash
GET /transactions/{transactionId}
```

**Response:**

```json
{
  "id": "Transaction:...",
  "status": "PROCESSING",
  "createdAt": "2025-10-03T15:00:00Z",
  "updatedAt": "2025-10-03T15:02:00Z"
}
```

Poll every 5-10 seconds until terminal status reached.

### Listing Transactions

Query all transactions for a customer or date range:

```bash
GET /transactions?customerId=Customer:abc123&startDate=2025-10-01T00:00:00Z&limit=50
```

**Response:**

```json
{
  "data": [
    {
      "id": "Transaction:...",
      "status": "COMPLETED",
      "type": "OUTGOING",
      "sentAmount": {"amount": 100000, "currency": {"code": "USD"}},
      "receivedAmount": {"amount": 92000, "currency": {"code": "EUR"}},
      "settledAt": "2025-10-03T15:05:00Z"
    }
  ],
  "hasMore": false,
  "nextCursor": null
}
```

Use for reconciliation and reporting.

## Failure Handling

### Common Failure Reasons

| Failure Reason | Description | Recovery |
|----------------|-------------|----------|
| `QUOTE_EXPIRED` | Quote expired before execution | Create new quote |
| `INSUFFICIENT_BALANCE` | Source account lacks funds | Fund account, retry |
| `INVALID_BANK_ACCOUNT` | Destination account invalid | Verify account details |
| `PAYMENT_APPROVAL_TIMED_OUT` | Webhook approval not received in 5s | Improve webhook response time |
| `OFFRAMP_FAILED` | Failed to deliver to destination | Check destination account status |
| `TIMEOUT` | Transaction timed out | Retry or contact support |

### Automatic Refunds

For **outgoing transactions**:
- Source account is debited when transaction is created
- If transaction fails, funds are **automatically refunded**
- Refund appears as a separate transaction
- `REFUNDED` status on original transaction

For **incoming transactions**:
- Destination account is NOT credited until success
- If transaction fails, no refund needed (funds never left source)

## Best Practices

<AccordionGroup>
  <Accordion title="Always use webhooks for status updates">
    Don't rely solely on polling:

    ```javascript
    // ✅ Good: Webhook-driven updates
    app.post('/webhooks/grid', async (req, res) => {
      await handleTransactionUpdate(req.body.transaction);
      res.status(200).send();
    });

    // ❌ Bad: Constant polling
    setInterval(() => getTransaction(txId), 5000);
    ```
  </Accordion>

  <Accordion title="Store transaction IDs for reconciliation">
    Save transaction IDs to your database:

    ```javascript
    const transaction = await executeQuote(quoteId);
    await db.transactions.insert({
      gridTransactionId: transaction.id,
      internalPaymentId: paymentId,
      status: transaction.status,
      createdAt: new Date()
    });
    ```
  </Accordion>

  <Accordion title="Handle idempotency">
    Use idempotency keys for safe retries:

    ```javascript
    const idempotencyKey = `payment-${userId}-${Date.now()}`;
    await createQuote({...params, idempotencyKey});
    ```
  </Accordion>

  <Accordion title="Provide clear status messages to users">
    Translate technical statuses to user-friendly messages:

    ```javascript
    function getUserMessage(status, failureReason) {
      if (status === 'PENDING') return 'Payment processing...';
      if (status === 'PROCESSING') return 'Payment in progress...';
      if (status === 'COMPLETED') return 'Payment delivered!';
      if (status === 'FAILED') {
        if (failureReason === 'INSUFFICIENT_BALANCE') {
          return 'Insufficient funds. Please add money and try again.';
        }
        return 'Payment failed. Please try again or contact support.';
      }
    }
    ```
  </Accordion>
</AccordionGroup>
